<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>14</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spell Background Primative Init
scr_InitStage2Background()

lightrot = 0

SpellBack = surface_create(1024, 768)

StarAngle = 90

ANGLE = 360

steps = 50

xx = 0
yy = 0

FadeTime = 30
WobbleSwitch = false
wobble = 0

VerAlpha[0] = 1 
VerAlpha[1] = 0.8
VerAlpha[2] = 0.5

radius[0] = 0
minradius[0] = 0

radius[1] = 0
minradius[1] = 0

radius[2] = 0
minradius[2] = 0

OneTimeSwitch = false
cloudDir = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.SpellcardType = "Spellcard"
{
    depth = 16
}
else
{
    depth = 14
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wobble

if instance_exists(obj_ParPlayer)
{
    if WobbleSwitch = false
    {
        wobble += 0.1
    }
    else
    {
        wobble -= 0.1
    }

    if wobble &gt;= 3
    {
        WobbleSwitch = true
    }

    if wobble &lt;= 0
    {
        WobbleSwitch = false
    }
}
else
{
    WobbleSwitch = false
    
    if wobble &gt; 0
    {
        wobble -= 1
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Ring 1
RadiusAlter = 0
//draw_enable_alphablend(true)

if !surface_exists(SpellBack)
{
  SpellBack = surface_create(1024, 768)
}

surface_set_target(SpellBack) 
//===Draw sprites go here===

script_execute(scr_Stage2Background)
draw_sprite_ext(spr_Lanternglow, 0, xx, yy, 2, 2, 0, c_white, 0.1)

//==========================
surface_reset_target()
//draw_set_colour(c_white)

draw_set_alpha(VerAlpha[0])

//=== Primative Init =======

if instance_exists(obj_ParPlayer)
{
    xx = obj_ParPlayer.x
    yy = obj_ParPlayer.y
    
    if radius[0] &lt;= 202
    {
        radius[0]  += 202/FadeTime
    }
    
}
else
{
    if radius[0] &gt;= 0
    {
        radius[0]  -= 202/FadeTime
        xx = x
        yy = y
    }
    else
    {
        xx = 0
        yy = 0
    }
    
    minradius[0] = 0
}

var i

TexStartx = (xx-radius[0]+wobble)/room_width //surface_get_width(global.backside)
TexStarty = (yy-radius[0]+wobble)/room_height //surface_get_height(global.backside)

TexEndx = (xx+radius[0]+wobble)/room_width
TexEndy = (yy+radius[0]+wobble)/room_height

//Primative 
//first ring
TEX = surface_get_texture(SpellBack)

draw_primitive_begin_texture(pr_trianglestrip, TEX)


xAlt = xx + lengthdir_x(minradius[0], ANGLE * 0 / steps + StarAngle)
yAlt = yy + lengthdir_y(minradius[0], ANGLE * 0 / steps + StarAngle)
draw_vertex_texture_colour(xx + lengthdir_x(minradius[0], StarAngle), yy + lengthdir_y(minradius[0], StarAngle), xAlt/room_width, yAlt/room_height, c_white, VerAlpha[0])

for(i = 0; i &lt;= steps; i += 1)
{
    //draw_vertex(xx + lengthdir_x(radius, ANGLE  * i / steps), yy + lengthdir_y(radius, ANGLE  * i / steps))
    
    if RadiusAlter = 0
    {
        xAlt = xx + lengthdir_x(radius[0]+wobble, ANGLE * i / steps + StarAngle)
        yAlt = yy + lengthdir_y(radius[0]+wobble, ANGLE * i / steps + StarAngle)
    }
    else
    {                        
        xAlt = xx + lengthdir_x(minradius[0], ANGLE * i / steps + StarAngle)
        yAlt = yy + lengthdir_y(minradius[0], ANGLE * i / steps + StarAngle)
    }
    
    draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white, VerAlpha[0])
    RadiusAlter =! RadiusAlter
}

xAlt = xx + lengthdir_x(minradius[0], StarAngle)
yAlt = yy + lengthdir_y(minradius[0], StarAngle)
draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white, VerAlpha[0])

xAlt = xx + lengthdir_x(radius[0]+wobble , StarAngle)
yAlt = yy + lengthdir_y(radius[0]+wobble , StarAngle)
draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white, VerAlpha[0])

draw_primitive_end()
draw_enable_alphablend(true)
draw_set_alpha(1)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Ring 2
RadiusAlter = 0
lightrot += 5
lightrot = lightrot % 360

draw_set_alpha(VerAlpha[1])
//=== Primative Init =======

if instance_exists(obj_ParPlayer)
{
    xx = obj_ParPlayer.x
    yy = obj_ParPlayer.y
    
    if radius[1] &lt;= 212
    {
        radius[1]  += 212/FadeTime
        minradius[1] += 200/FadeTime
    } 
}
else
{
    if radius[1] &gt; 0
    {
        radius[1]  -= 212/FadeTime
        minradius[1] -= 200/FadeTime
        xx = x
        yy = y
    }
    else
    {
        xx = 0
        yy = 0
    }
}

var i

TexStartx = (xx-radius[1]+wobble)/room_width //surface_get_width(global.backside)
TexStarty = (yy-radius[1]+wobble)/room_height //surface_get_height(global.backside)

TexEndx = (xx+radius[1]+wobble)/room_width
TexEndy = (yy+radius[1]+wobble)/room_height

//Primative 
//first ring
TEX = surface_get_texture(SpellBack)

draw_primitive_begin_texture(pr_trianglestrip, TEX)

xAlt = xx + lengthdir_x(minradius[1]+wobble, ANGLE * 0 / steps + StarAngle+lightrot)
yAlt = yy + lengthdir_y(minradius[1]+wobble, ANGLE * 0 / steps + StarAngle+lightrot)
draw_vertex_texture_colour(xx + lengthdir_x(minradius[1]+wobble, StarAngle+lightrot), yy + lengthdir_y(minradius[1]+wobble, StarAngle+lightrot), xAlt/room_width, yAlt/room_height, c_white, VerAlpha[1])

for(i = 0; i &lt;= steps; i += 1)
{
    //draw_vertex(xx + lengthdir_x(radius, ANGLE  * i / steps), yy + lengthdir_y(radius, ANGLE  * i / steps))
    
    if RadiusAlter = 0
    {
        xAlt = xx + lengthdir_x(radius[1]+wobble, ANGLE * i / steps + StarAngle+lightrot)
        yAlt = yy + lengthdir_y(radius[1]+wobble, ANGLE * i / steps + StarAngle+lightrot)
    }
    else
    {
        xAlt = xx + lengthdir_x(minradius[1]+wobble, ANGLE * i / steps + StarAngle+lightrot)
        yAlt = yy + lengthdir_y(minradius[1]+wobble, ANGLE * i / steps + StarAngle+lightrot)
    }
    
    draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white,  VerAlpha[1])
    RadiusAlter =! RadiusAlter
}

xAlt = xx + lengthdir_x(minradius[1]+wobble, StarAngle+lightrot)
yAlt = yy + lengthdir_y(minradius[1]+wobble, StarAngle+lightrot)
draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white,  VerAlpha[1])

xAlt = xx + lengthdir_x(radius[1]+wobble, StarAngle+lightrot)
yAlt = yy + lengthdir_y(radius[1]+wobble, StarAngle+lightrot)
draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white,  VerAlpha[1])

draw_primitive_end()
draw_enable_alphablend(true)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Ring 3
RadiusAlter = 0

draw_set_alpha(VerAlpha[2])
//=== Primative Init =======
if instance_exists(obj_ParPlayer)
{
    xx = obj_ParPlayer.x
    yy = obj_ParPlayer.y
    
    if radius[2] &lt;= 220
    {
        radius[2]  += 220/FadeTime
        minradius[2] += 210/FadeTime
    } 
}
else
{
    if radius[2] &gt; 0
    {
        radius[2]  -= 220/FadeTime
        minradius[2] -= 210/FadeTime
        xx = x
        yy = y
    }
    else
    {
        xx = 0
        yy = 0
    }
}

var i

TexStartx = (xx-radius[2]+wobble)/room_width //surface_get_width(global.backside)
TexStarty = (yy-radius[2]+wobble)/room_height //surface_get_height(global.backside)

TexEndx = (xx+radius[2]+wobble)/room_width
TexEndy = (yy+radius[2]+wobble)/room_height

//Primative 
//first ring
TEX = surface_get_texture(SpellBack)

draw_primitive_begin_texture(pr_trianglestrip, TEX)

xAlt = xx + lengthdir_x(minradius[2]+wobble, ANGLE * 0 / steps + StarAngle-lightrot)
yAlt = yy + lengthdir_y(minradius[2]+wobble, ANGLE * 0 / steps + StarAngle-lightrot)
draw_vertex_texture_colour(xx + lengthdir_x(minradius[2]+wobble, StarAngle-lightrot), yy + lengthdir_y(minradius[2]+wobble, StarAngle+lightrot), xAlt/room_width, yAlt/room_height, c_white, VerAlpha[2])

for(i = 0; i &lt;= steps; i += 1)
{
    //draw_vertex(xx + lengthdir_x(radius, ANGLE  * i / steps), yy + lengthdir_y(radius, ANGLE  * i / steps))
    
    if RadiusAlter = 0
    {
        xAlt = xx + lengthdir_x(radius[2]+wobble, ANGLE * i / steps + StarAngle-lightrot)
        yAlt = yy + lengthdir_y(radius[2]+wobble, ANGLE * i / steps + StarAngle-lightrot)
    }
    else
    {
        xAlt = xx + lengthdir_x(minradius[2]+wobble, ANGLE * i / steps + StarAngle-lightrot)
        yAlt = yy + lengthdir_y(minradius[2]+wobble, ANGLE * i / steps + StarAngle-lightrot)
    }
    
    draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white,  VerAlpha[2])
    RadiusAlter =! RadiusAlter
}

xAlt = xx + lengthdir_x(minradius[2]+wobble, StarAngle-lightrot)
yAlt = yy + lengthdir_y(minradius[2]+wobble, StarAngle-lightrot)
draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white,  VerAlpha[2])

xAlt = xx + lengthdir_x(radius[2]+wobble, StarAngle-lightrot)
yAlt = yy + lengthdir_y(radius[2]+wobble, StarAngle-lightrot)
draw_vertex_texture_colour(xAlt, yAlt, xAlt/room_width, yAlt/room_height, c_white,  VerAlpha[2])

draw_primitive_end()
draw_enable_alphablend(true)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Redset</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_alpha(1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
